From blp at nicira.com  Fri Oct  2 20:16:37 2009
From: blp at nicira.com (Ben Pfaff)
Date: Fri,  2 Oct 2009 17:16:37 -0700
Subject: [ovs-dev] [PATCH v2] vswitch: Allow user to set Ethernet address of
	any internal interface.
Message-ID: <1254528997-3470-1-git-send-email-blp@nicira.com>

Until now the vswitch configuration file has allowed the user to configure
the MAC address on bridge local ports only.  This commit adds the ability
to configure them on any internal interface.

It would be logical to extend this to any bridge port, period, but many
network devices must be brought down before their Ethernet addresses may be
changed.  Bringing a network interface down and then back up can reset a
lot of state, so as we don't actually need the ability to change any bridge
port's MAC address yet this commit does not implement it.

CC: Ian Campbell <Ian.Campbell at citrix.com>
---
 vswitchd/bridge.c               |   36 ++++++++++++++
 vswitchd/ovs-vswitchd.conf.5.in |  103 +++++++++++++++++++++++++++++++--------
 2 files changed, 119 insertions(+), 20 deletions(-)

diff --git a/vswitchd/bridge.c b/vswitchd/bridge.c
index 2d788ae..36be700 100644
--- a/vswitchd/bridge.c
+++ b/vswitchd/bridge.c
@@ -243,6 +243,7 @@ static struct iface *iface_lookup(const struct bridge *, const char *name);
 static struct iface *iface_from_dp_ifidx(const struct bridge *,
                                          uint16_t dp_ifidx);
 static bool iface_is_internal(const struct bridge *, const char *name);
+static void iface_set_mac(struct iface *);
 
 /* Hooks into ofproto processing. */
 static struct ofhooks bridge_ofhooks;
@@ -585,8 +586,18 @@ bridge_reconfigure(void)
     LIST_FOR_EACH (br, struct bridge, node, &all_bridges) {
         for (i = 0; i < br->n_ports; i++) {
+            int j;
             struct port *port = br->ports[i];
+
             port_update_vlan_compat(port);
             port_update_bonding(port);
+
+            for (j = 0; j < port->n_ifaces; j++) {
+                struct iface *iface = port->ifaces[j];
+                if (iface->dp_ifidx != ODPP_LOCAL
+                    && iface_is_internal(br, iface->name)) {
+                    iface_set_mac(iface);
+                }
+            }
         }
     }
     LIST_FOR_EACH (br, struct bridge, node, &all_bridges) {
@@ -3135,6 +3145,32 @@ iface_is_internal(const struct bridge *br, const char *iface)
 
     return false;
 }
+
+/* Set Ethernet address of 'iface', if one is specified in the configuration
+ * file. */
+static void
+iface_set_mac(struct iface *iface)
+{
+    uint64_t mac = cfg_get_mac(0, "iface.%s.mac", iface->name);
+    if (mac) {
+        static uint8_t ea[ETH_ADDR_LEN];
+
+        eth_addr_from_uint64(mac, ea);
+        if (eth_addr_is_multicast(ea)) {
+            VLOG_ERR("interface %s: cannot set MAC to multicast address",
+                     iface->name);
+        } else if (iface->dp_ifidx == ODPP_LOCAL) {
+            VLOG_ERR("ignoring iface.%s.mac; use bridge.%s.mac instead",
+                     iface->name, iface->name);
+        } else {
+            int error = netdev_set_etheraddr(iface->netdev, ea);
+            if (error) {
+                VLOG_ERR("interface %s: setting MAC failed (%s)",
+                         iface->name, strerror(error));
+            }
+        }
+    }
+}
 
 /* Port mirroring. */
 
